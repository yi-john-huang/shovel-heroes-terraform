# Project Structure

## Directory Organization
```
.
├── .kiro/                          # SDD workflow files
│   ├── steering/                   # Project steering documents
│   │   ├── product.md              # Product overview and features
│   │   ├── tech.md                 # Technology stack and commands
│   │   ├── structure.md            # This file - project organization
│   │   ├── linus-review.md         # Code review guidelines
│   │   ├── commit.md               # Commit message standards
│   │   ├── tdd-guideline.md        # Test-driven development practices
│   │   ├── security-check.md       # Security checklist (OWASP Top 10)
│   │   └── AGENTS.md               # AI agent workflow guidance
│   └── specs/                      # Feature specifications
├── scripts/                        # Automation and utility scripts
│   └── validate.sh                 # Comprehensive validation script
├── secrets/                        # Sensitive configuration (gitignored)
├── plans/                          # Terraform execution plans (gitignored)
├── logs/                           # Validation and execution logs (gitignored)
├── CLAUDE.md                       # Project instructions and quick commands
├── README.md                       # Project documentation
├── .gitignore                      # Git ignore patterns
├── terraform.tfvars.example        # Example configuration
├── terraform.tfvars.template       # Configuration template
├── versions.tf                     # Terraform and provider version constraints
├── provider.tf                     # Provider configurations (AWS, Cloudflare, GitHub)
├── backend.tf                      # S3 backend configuration
├── variable.tf                     # Input variable declarations
├── data.tf                         # Data source definitions
├── outputs.tf                      # Resource outputs
├── vpc.tf                          # VPC, subnets, routing, NAT gateways
├── vpc_security_groups.tf          # Security groups for different tiers
├── eks.tf                          # EKS cluster with node groups
├── iam_eks.tf                      # IAM roles for EKS
├── iam_codepipeline.tf             # IAM roles for CI/CD
├── rds.tf                          # PostgreSQL database configuration
├── s3.tf                           # S3 buckets with lifecycle policies
└── cloudwatch.tf                   # Monitoring, logging, and dashboards
```

## Key Directories

### `.kiro/`
Spec-Driven Development (SDD) workflow directory containing:
- **steering/**: Project guidance documents that define architecture, patterns, and standards
- **specs/**: Feature specifications and requirements (when using SDD workflow)

### `scripts/`
Automation scripts for infrastructure management:
- **validate.sh**: Comprehensive validation with formatting, validation, security scanning, and cost estimation

### `secrets/`
Sensitive configuration files (excluded from version control):
- API tokens, credentials, and environment-specific secrets
- Referenced by Terraform variables but never committed

### `plans/` (gitignored)
Timestamped Terraform execution plans:
- Generated by `validate.sh` script
- Format: `tfplan_YYYYMMDD_HHMMSS.out`
- Automatically cleaned up (keeps last 10)

### `logs/` (gitignored)
Validation and execution logs:
- Timestamped log files from validation runs
- Format: `validate_YYYYMMDD_HHMMSS.log`
- Automatically cleaned up (keeps last 10)

## File Naming Conventions

### Terraform Files
- **Core configuration**: `versions.tf`, `provider.tf`, `backend.tf`
- **Variable definitions**: `variable.tf`, `outputs.tf`, `data.tf`
- **Resource files**: Lowercase with service name (e.g., `vpc.tf`, `eks.tf`, `rds.tf`)
- **IAM roles**: Prefix with `iam_` and service name (e.g., `iam_eks.tf`, `iam_codepipeline.tf`)
- **Security**: `vpc_security_groups.tf` for all security group definitions

### Resource Naming Pattern
Resources follow a consistent naming convention:
```hcl
resource "aws_resource_type" "descriptive_name" {
  name = "${var.project_name}-${local.env_type}-resource-purpose"

  tags = merge(local.common_tags, {
    Name = "${var.project_name}-${local.env_type}-resource-purpose"
  })
}
```

Examples:
- EKS Cluster: `${var.project_name}-${local.env_type}-eks`
- RDS Instance: `${var.project_name}-${local.env_type}-postgres`
- S3 Bucket: `${var.project_name}-${local.env_type}-storage`

### Naming Standards
- **Resources**: snake_case for Terraform resource names
- **Variables**: snake_case (e.g., `project_name`, `primary_region`)
- **Locals**: snake_case (e.g., `common_tags`, `eks_cluster_name`)
- **Tags**: PascalCase for tag keys (e.g., `Project`, `Environment`, `ManagedBy`)
- **Files**: lowercase with hyphens for scripts (e.g., `validate.sh`)

## Code Organization Patterns

### Separation of Concerns
Each Terraform file handles a specific domain:
- **Networking**: `vpc.tf`, `vpc_security_groups.tf`
- **Compute**: `eks.tf`
- **Data**: `rds.tf`, `s3.tf`
- **Monitoring**: `cloudwatch.tf`
- **Security**: `iam_*.tf` files, security groups
- **Configuration**: `variable.tf`, `outputs.tf`, `data.tf`

### Conditional Resources
Resources use feature flags for conditional deployment:
```hcl
resource "aws_resource" "example" {
  count = local.feature_enabled ? 1 : 0
  # Resource configuration
}
```

Common feature flags (defined in `local.tf`):
- `eks_enabled`: Deploy EKS cluster
- `rds_enabled`: Deploy RDS database
- `s3_enabled`: Deploy S3 buckets
- `taipei_enabled`: Deploy Taiwan region resources

### Multi-Region Support
Provider aliases enable multi-region deployments:
```hcl
provider "aws" {
  alias  = "taipei"
  region = "ap-northeast-2"
}

resource "aws_resource" "taipei_resource" {
  provider = aws.taipei
  count    = local.taipei_enabled ? 1 : 0
}
```

## Module Organization

### Module Structure
- **External Modules**: Use official Terraform Registry modules
  - EKS: `terraform-aws-modules/eks/aws`
  - Version pinning: Use `~>` for minor version updates
- **Custom Resources**: Define directly in root module
- **Reusable Components**: Consider extracting to local modules in `modules/` directory

### Module Best Practices
- Pin module versions for stability
- Use module outputs for inter-module dependencies
- Document module inputs and outputs
- Test modules in isolation when possible

## Architectural Principles

### Infrastructure as Code Principles
- **Declarative Configuration**: Define desired state, let Terraform manage changes
- **Version Control**: All infrastructure code in Git
- **Immutable Infrastructure**: Replace rather than modify resources
- **State Management**: Remote state in S3 with locking

### Security by Design
- **Least Privilege**: Minimal IAM permissions
- **Encryption**: At-rest and in-transit for all data
- **Network Isolation**: Multi-tier security groups
- **Secrets Management**: Sensitive variables properly secured

### Operational Excellence
- **Automation**: Validation scripts for consistency
- **Monitoring**: CloudWatch integration for all resources
- **Disaster Recovery**: Automated backups, multi-AZ deployment
- **Cost Optimization**: SPOT instances, lifecycle policies

### Separation of Concerns
- Each module handles a specific responsibility
- Clear boundaries between networking, compute, data, and security
- IAM roles separated by service (`iam_eks.tf`, `iam_codepipeline.tf`)
- Security groups isolated in dedicated file

## Development Patterns

### Configuration Management
1. **Variables**: Define all configurable values in `variable.tf`
2. **Locals**: Compute derived values in local value blocks
3. **Data Sources**: Fetch existing resource information via `data.tf`
4. **Outputs**: Export important values via `outputs.tf`

### Resource Dependencies
- Use implicit dependencies via resource references
- Explicit dependencies via `depends_on` when necessary
- Module dependencies through outputs and variables

### Tagging Strategy
All resources include standardized tags:
```hcl
locals {
  common_tags = {
    Project     = var.project_name
    Environment = local.env_type
    ManagedBy   = "terraform"
  }
}
```

Resource-specific tags merged with common tags:
```hcl
tags = merge(local.common_tags, {
  Name = "${var.project_name}-${local.env_type}-resource"
  Role = "specific-purpose"
})
```

## Testing Structure

### Validation Workflow
1. **Format Check**: `terraform fmt -check -recursive`
2. **Syntax Validation**: `terraform validate`
3. **Security Scanning**: `tfsec .` (if available)
4. **Cost Estimation**: `infracost breakdown --path .` (if available)
5. **Plan Generation**: `terraform plan -out=plans/tfplan.out`

### Testing Strategy
- **Pre-deployment**: Always run `./scripts/validate.sh`
- **Plan Review**: Review generated plans before applying
- **Non-prod Testing**: Test in development environment first
- **Post-deployment**: Monitor CloudWatch metrics

### Quality Checks
- No hardcoded credentials
- Proper resource tagging
- Security group rules reviewed
- IAM policies follow least privilege
- Encryption enabled for data at rest

## Build Output

### Generated Artifacts
- **Plan Files**: Timestamped execution plans in `plans/`
- **Log Files**: Validation logs in `logs/`
- **State Files**: Remote state in S3 backend

### Cleanup Process
Automated cleanup via `validate.sh`:
- Keeps last 10 plan files
- Keeps last 10 log files
- Removes older artifacts automatically

### State Management
- **Backend**: S3 with DynamoDB locking
- **Encryption**: State files encrypted at rest
- **Versioning**: S3 versioning enabled for recovery
- **Locking**: DynamoDB prevents concurrent modifications

## Configuration Files

### Core Configuration
- **versions.tf**: Terraform and provider version constraints
- **provider.tf**: AWS, Cloudflare, and GitHub provider configuration
- **backend.tf**: S3 backend with state locking
- **variable.tf**: All input variable declarations
- **outputs.tf**: Resource outputs for external use
- **data.tf**: Data sources for existing resources

### Documentation Files
- **CLAUDE.md**: Quick reference and steering file pointers
- **README.md**: Comprehensive project documentation
- **SECURITY.md**: Security guidelines and practices
- **terraform.tfvars.example**: Example configuration values
- **terraform.tfvars.template**: Template for new environments

### Steering Documents
Located in `.kiro/steering/`:
- **product.md**: Product overview and features
- **tech.md**: Technology stack and development workflow
- **structure.md**: This file - project organization
- **linus-review.md**: Code review standards
- **commit.md**: Commit message conventions
- **tdd-guideline.md**: Test-driven development practices
- **security-check.md**: Security checklist aligned to OWASP Top 10
